#' Variance-based first-order indices and total effects indices
#'
#' This function computes the variance-based first-order indices
#' (or main effects) and total effects indices (Homma and Saltelli, 1996).
#' The indices are approximated by the estimator suggested e.g. 
#' in Saltelli et al. (2008) and (2010).
#'
#' NOTES:
#'
#' (*) By default, here we use the estimators described by Saltelli et al.
#'     (2008) and Saltelli et al. (2010) (see comments in the code for
#'     specific references to the equations implemented here!).
#'     These are obtained from 3 sets of output samples (\code{YA}, \code{YB} and \code{YC}), 
#'     which are obtained by model evaluation against three input matrices 
#'     \code{XA}, \code{XB} and \code{XC} generated by the \code{\link{vbsa_resampling}} function: 
#'     - see example below about how to use \code{\link{vbsa_resampling}}
#'     - see help of \code{\link{vbsa_resampling}} to learn more about \code{XA}, \code{XB} and \code{XC}.
#'
#' (**) If bootstrapping is used, \code{Si} and \code{STi} are the average of the
#'      respective \code{Nboot} estimates obtained at each bootstrap resampling.
#'
#' @param YA vector \code{(N)}, set of output samples
#' @param YB vector \code{(N)}, set of output samples (independent from \code{YA})
#' @param YC vector \code{(N*M)}, set of output samples from resampling (*)
#' @param Nboot scalar, number of resamples used for boostrapping (default: 0)
#' @param alfa scalar, significance level for the confidence intervals estimated by bootstrapping (default: 0.05)
#'
#' @return List containing: 
#' \itemize{
#'   \item \code{Si} estimates of the main effects at different sampling size
#'   \item \code{STi} estimates of the total effects at different sampling size
#' }
#' If \code{Nboot > 1} it also contains
#' \itemize{ 
#'   \item \code{Si_sd} standard deviation of main effects at different sampling size
#'   \item \code{STi_sd} standard deviation of total effects at different sampling size
#'   \item \code{Si_lb} lower bound of main effects at different sampling size
#'   \item \code{STi_lb} lower bound of total effects at different sampling size
#'   \item \code{Si_ub} upper bound of main effects at different sampling size
#'   \item \code{STi_ub} upper bound of total effects at different sampling size. 
#'}
#' All output arguments are matrices of size \code{(R, M)}
#'
#' @references Homma, T. and A., Saltelli (1996). Importance measures in global 
#' sensitivity analysis of nonlinear models. 
#' Reliability Engineering & System Safety, 52(1), 1-17.
#'
#' Saltelli et al. (2008), Global Sensitivity Analysis, The Primer, Wiley.
#'
#' Saltelli et al. (2010), Variance based sensitivity analysis of model 
#' output. Design and estimator for the total sensitivity index, Computer 
#' Physics Communications, 181, 259-270.

#' @seealso \code{\link{vbsa_resampling}}

#' @export

#' @examples
#'
#' fun_test  <- "ishigami_homma_function"
#' M <- 3 
#' distrfun <- "unif"
#' distrpar  <- c(-pi, pi)
#' N <- 1000
#' sampstrat <- "lhs"
#' X <- AAT_sampling(sampstrat, M, distrfun, distrpar, 2 * N)
#' XABC <- vbsa_resampling(X)
#' YA <- model_execution(fun_test, XABC$XA)
#' YB <- model_execution(fun_test, XABC$XB)
#' YC <- model_execution(fun_test, XABC$XC)
#' SiSTi <- vbsa_indices(YA,YB,YC)

vbsa_indices <- function(YA, YB, YC, Nboot = 0, alfa = 0.05){

##############
# Check inputs
##############

N <- length(YA)
M <- length(YC) / N

YA <- matrix(YA, ncol = 1)
YB <- matrix(YB, ncol = 1)

stopifnot(M == floor(M))

if(!is.matrix(YC)){
	YC <- matrix(YC, N, M) 
	} 
	
if(ncol(YC) == 1) YC <- matrix(YC, nrow = nrow(YA))	 

stopifnot(ncol(YA) == 1, ncol(YB) == 1, ncol(YC) == M, nrow(YC) == N, nrow(YB) == N)

###################################
# Recover and check optional inputs
###################################

stopifnot(is.scalar(Nboot), Nboot >=0, Nboot == floor(Nboot),
is.numeric(alfa), alfa <= 1, alfa >= 0)

#################
# Compute indices
#################

if (Nboot >1){
    bootsize <- N 

    Si_n  <- matrix(NA, Nboot, M)
    STi_n <- matrix(NA, Nboot, M)
    
    B <- matrix(sample.int(N, N * Nboot, replace = TRUE), N, Nboot)
    
    SiSTn <- apply(B, 2, function(b) compute_indices_vbsa(YA[b,],YB[b,],YC[b,]))
    
    Si_n <- SiSTn[seq(1, 2 * M, by = 2), ]
    STi_n <- SiSTn[seq(2, 2 * M, by = 2), ]
    
    Si      <- rowMeans(Si_n)
    Si_sd   <- apply(Si_n, 1, sd)
    Si_sort   <- apply(Si_n, 1, sort) 
    Si_lb   <- Si_sort[max(1,round(Nboot * alfa / 2)),]
    Si_ub   <- Si_sort[round(Nboot * (1 - alfa / 2)),]
    
    STi     <- rowMeans(STi_n)
    STi_sd  <- apply(STi_n, 1, sd)
    STi_sort   <- apply(STi_n, 1, sort) 
    STi_lb  <- STi_sort[max(1,round(Nboot * alfa / 2)),]
    STi_ub  <- STi_sort[round(Nboot * (1 - alfa / 2)),]
    
    
    robj <- rbind(Si = Si, Si_sd = Si_sd, Si_lb = Si_lb, Si_ub = Si_ub, STi = STi, STi_sd = STi_sd, STi_lb = STi_lb, STi_ub = STi_ub)
    
    cat(sprintf('\n \t main    total    (average over %d bootstrap resamples)\n',Nboot))
    cat(sprintf(' X%d:\t %1.4f\t %1.4f\n', 1:M, Si, STi))
    cat(sprintf('\n sum:\t %1.4f\t %1.4f\n\n', sum(Si), sum(STi)))
 }  else {
 	
    robj <- compute_indices_vbsa(YA, YB, YC)  
    
    cat('\n \t main    total \n')
    cat(sprintf(' X%d:\t %1.4f\t %1.4f\n', 1:M, robj[1,], robj[2,]))
    cat(sprintf('\n sum:\t %1.4f\t %1.4f\n\n', sum(robj[1,]), sum(robj[2,])))

}

	robj

}