% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/OAT_sampling.R
\name{OAT_sampling}
\alias{OAT_sampling}
\title{One-At-the-Time sampling strategy}
\usage{
OAT_sampling(r, M, distr_fun, distr_par, samp_strat, des_type)
}
\arguments{
\item{r}{positive integer number , number of elementary effects}

\item{M}{positive integer number , number of inputs}

\item{distr_fun}{probability distribution function of each input. list (eg: \code{"unif"}) if all inputs have the same pdf or a list of length \code{M} strings (eg: \code{list("unif", "norm")}) otherwise. See help of \code{\link{AAT_sampling}} to check supported PDF types.}

\item{distr_par}{parameters of the probability distribution function - row vector if all input pdfs have the same parameters - list of \code{M} vectors otherwise}

\item{samp_strat}{sampling strategy - string Options: \code{"rsu"}: random uniform, \code{"lhs"}: latin hypercube.}

\item{des_type}{design type - string. Options: \code{"trajectory"}, \code{"radial"}}
}
\value{
\code{X} matrix of sampling datapoints where \code{EE} must be computed. This is a matrix with \code{r * (M + 1)} rows and \code{M} columns. Each row is a point in the input space. Rows are sorted in \code{r} blocks, each including \code{M + 1} rows. Within each block, points (rows) differ in one component at the time. Thus, each block can be used to compute one Elementary Effect \code{(EE_i)} for each model input \code{(i = 1, ...,M)}.
}
\description{
This function builds a matrix \code{X} of input samples to be used for the Elementary Effects Test, using a One-At-the-Time sampling strategy as described in Campolongo et al. (2011).
}
\examples{
# Example 1: 2 inputs, both from Unif[0,3]
r <-  10
M <-  2
distr_fun <-  "unif"
distr_par <-  c(0, 3)
samp_strat <-  "lhs"
des_type <-  "trajectory"
X <-  OAT_sampling(r, M, distr_fun, distr_par, samp_strat, des_type)
# Plot results:
plot(X[,1], X[,2], col = rep(rainbow(r), each = M + 1), pch = 19,
xlab = expression(x[1]), ylab = expression(x[2]))
for(k in 0:(r-1)){
 segments(X[c(1,3) + (M+1) * k, 1], X[c(1,3) + (M+1) * k, 2],
X[2 + (M+1) * k, 1], X[2 + (M+1) * k, 2], lty = 2, col = "gray")
}
# Example 2: 2 inputs, one from Unif[0,3], one from Unif[1,5]
distr_fun <-  "unif" 
distr_par <- list(c(0, 3), c(1, 5))
X <-  OAT_sampling(r, M, distr_fun, distr_par, samp_strat, des_type)
plot(X[,1], X[,2], col = rep(rainbow(r), each = M + 1), pch = 19,
xlab = expression(x[1]), ylab = expression(x[2]))
for(k in 0:(r-1)){
 segments(X[c(1,3) + (M+1) * k, 1], X[c(1,3) + (M+1) * k, 2],
X[2 + (M+1) * k, 1], X[2 + (M+1) * k, 2], lty = 2, col = "gray")
}
}
\references{
Campolongo F., Saltelli, A. and J. Cariboni (2011), From screening to quantitative sensitivity analysis. A unified approach, Computer Physics Communications, 182(4), 978-988.
}
\seealso{
\code{\link{AAT_sampling}}
}
